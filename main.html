<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Калькулятор Четвертной Оценки</title>
    <!-- Подключение Tailwind CSS для стилизации -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3ffec; 
        }
        .input-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            /* Уменьшаем вертикальные отступы для уменьшения высоты */
            padding: 0.5rem !important; 
        }
        .input-item label {
            /* Уменьшаем размер метки, чтобы она помещалась */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            padding-right: 0.25rem;
        }
        .input-group {
            display: flex;
            align-items: center;
            flex-grow: 1;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
            border-radius: 0.375rem;
        }
        .input-group input {
            text-align: center;
            width: 50%;
            border-color: #d1d5db !important;
            padding: 0.35rem 0.5rem; /* Уменьшаем padding для уменьшения высоты */
            font-size: 0.9rem;
        }
        .input-group span {
             border-color: #d1d5db !important;
             padding: 0.35rem 0.5rem;
        }
        /* Уменьшаем размер иконки удаления */
        .input-item button svg {
            width: 1.1rem;
            height: 1.1rem;
        }

        /* Стиль для блока прогноза */
        .prediction-block {
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.375rem;
            background-color: #ffffff; 
            border: 1px dashed #d1d5db;
        }
        .prediction-block p {
            font-size: 0.75rem; /* text-xs */
            color: #4b5563; /* text-gray-600 */
        }

        /* Custom scrollbar style */
        .scroll-area::-webkit-scrollbar {
            width: 6px;
        }
        .scroll-area::-webkit-scrollbar-thumb {
            background-color: #a7a7a7;
            border-radius: 3px;
        }
    </style>
</head>
<body class="p-4 md:p-8 flex justify-center items-start min-h-screen"> 

    <div class="w-full max-w-2xl bg-white p-6 md:p-10 shadow-2xl rounded-xl border border-gray-100">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-2 text-center">Расчет Оценки за Четверть</h1>
        
        <p class="mb-6 text-base text-gray-700 text-center">
            Введите баллы для СОР/СОЧ в формате: **Получено / Максимум**. 
            Итоговая оценка рассчитывается по формуле: $\left(\frac{\sum \text{Факт. СОР}}{\sum \text{Макс. СОР}} \times 0.5\right) + \left(\frac{\sum \text{Факт. СОЧ}}{\sum \text{Макс. СОЧ}} \times 0.5\right)$.
        </p>

        <!-- Контейнеры для СОР и СОЧ (Адаптация: сетка 1x2 на десктопе, 1x1 на мобильном) -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            
            <!-- СОР - (50% веса) -->
            <div class="bg-indigo-50 p-4 rounded-lg shadow-inner border border-indigo-200">
                <h2 class="text-xl font-semibold text-indigo-700 mb-4 flex justify-between items-center">
                    СОРы (50% веса)
                    <button onclick="addAssessment('sor')" class="text-sm bg-indigo-500 hover:bg-indigo-600 text-white font-medium py-1 px-3 rounded-full transition duration-150 shadow-md">
                        + СОР
                    </button>
                </h2>
                <div id="sor-list" class="space-y-3 max-h-48 overflow-y-auto scroll-area">
                    <!-- Поля СОР будут добавлены JS -->
                </div>
            </div>

            <!-- СОЧ - (50% веса) -->
            <div class="bg-teal-50 p-4 rounded-lg shadow-inner border border-teal-200">
                <h2 class="text-xl font-semibold text-teal-700 mb-4 flex justify-between items-center">
                    СОЧи (50% веса)
                    <button onclick="addAssessment('soch')" class="text-sm bg-teal-500 hover:bg-teal-600 text-white font-medium py-1 px-3 rounded-full transition duration-150 shadow-md">
                        + СОЧ
                    </button>
                </h2>
                <div id="soch-list" class="space-y-3 max-h-48 overflow-y-auto scroll-area">
                    <!-- Поля СОЧ будут добавлены JS -->
                </div>
            </div>
        </div>

        <!-- Кнопка расчета -->
        <div class="flex justify-center mb-8">
            <button onclick="calculateGrade()" class="w-full md:w-auto px-10 py-3 bg-red-600 text-white font-bold text-lg rounded-full shadow-xl hover:bg-red-700 transition duration-300 transform hover:scale-[1.02] active:scale-95">
                Рассчитать Оценку
            </button>
        </div>

        <!-- Результат -->
        <div class="bg-white p-6 rounded-xl border-4 border-gray-200 shadow-inner">
            <h2 class="text-2xl font-bold text-gray-700 mb-4 border-b pb-2 text-center">Итоговый Результат</h2>
            
            <div class="grid grid-cols-2 gap-4 text-center">
                
                <div>
                    <p class="text-md text-gray-500 font-medium">Итоговый Процент (%)</p>
                    <div id="final-percentage" class="text-4xl font-extrabold text-gray-800 mt-2">—</div>
                </div>

                <div>
                    <p class="text-md text-gray-500 font-medium">Четвертная Оценка</p>
                    <div id="final-grade" class="text-6xl font-extrabold text-gray-800 mt-2">—</div>
                </div>
            </div>

            <div id="result-message" class="mt-4 text-center">
                <!-- Здесь будут отображаться детали расчета -->
            </div>
            
            <div class="mt-6 pt-4 border-t text-sm text-center text-gray-500">
                <p>Шкала: 5 (85–100%), 4 (65–84%), 3 (40–64%), 2 (меньше 40%).</p>
            </div>
        </div>

    </div>

    <script>
        let assessmentId = 0;

        // Пороговые значения оценок
        const GRADE_THRESHOLDS = {
            '5': 85,
            '4': 65,
            '3': 40,
            '2': 0, // Условно 0, так как это "меньше 40%"
        };

        /**
         * Создает HTML для одного поля ввода оценки (баллы/максимум).
         * Включает блок прогноза.
         * @param {string} type - Тип оценки ('sor' или 'soch').
         * @returns {string} HTML-строка.
         */
        function createAssessmentInput(type) {
            assessmentId++;
            const labelText = type === 'sor' ? 'СОР' : 'СОЧ';
            const bgColor = type === 'sor' ? 'bg-indigo-100' : 'bg-teal-100';
            const id = `${type}-${assessmentId}`;

            return `
                <div id="container-${id}" class="${bgColor} p-2 rounded-lg transition duration-150">
                    <div class="input-item">
                        <label class="w-12 text-center font-medium text-gray-700">${labelText}</label>
                        
                        <div class="input-group">
                            <input type="number" id="gained-${id}" min="0" placeholder="Получено"
                                class="border border-r-0 rounded-l-md shadow-inner focus:border-indigo-500 focus:ring focus:ring-indigo-500 focus:ring-opacity-50"
                                oninput="validateInput('${id}'); calculateGrade()">
                            <span class="text-lg font-bold text-gray-600 bg-white border-y">/</span>
                            <input type="number" id="max-${id}" min="1" placeholder="Максимум"
                                class="border border-l-0 rounded-r-md shadow-inner focus:border-indigo-500 focus:ring focus:ring-indigo-500 focus:ring-opacity-50"
                                oninput="validateInput('${id}'); calculateGrade()">
                        </div>

                        <button onclick="removeAssessment('${id}')" class="text-red-500 hover:text-red-700 transition duration-150">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.725-1.447A1 1 0 0011 2H9zM7 6v10h6V6H7z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                    <!-- Блок для отображения прогноза -->
                    <div id="prediction-for-${id}" class="prediction-block hidden"></div>
                </div>
            `;
        }
        
        /**
         * Валидация введенных баллов.
         * @param {string} id - Уникальный ID оценки.
         */
        function validateInput(id) {
            const gainedInput = document.getElementById(`gained-${id}`);
            const maxInput = document.getElementById(`max-${id}`);
            
            const gained = parseFloat(gainedInput.value);
            const max = parseFloat(maxInput.value);
            
            // Управление стилями ошибок
            const toggleError = (input, shouldBeError) => {
                input.classList.toggle('border-red-500', shouldBeError);
                input.classList.toggle('border-2', shouldBeError);
            };

            const gainedIsFilled = gainedInput.value.trim() !== '';
            const maxIsFilled = maxInput.value.trim() !== '';

            let isError = false;

            // 1. Максимум <= 0
            if (maxIsFilled && max <= 0) {
                 toggleError(maxInput, true);
                 isError = true;
            } else {
                 toggleError(maxInput, false);
            }

            // 2. Получено < 0
            if (gainedIsFilled && gained < 0) {
                 toggleError(gainedInput, true);
                 isError = true;
            } else if (!isError) {
                 toggleError(gainedInput, false);
            }

            // 3. Получено > Максимум
            if (gainedIsFilled && maxIsFilled && gained > max) {
                 toggleError(gainedInput, true);
                 toggleError(maxInput, true);
                 isError = true;
            } else if (!isError) {
                 toggleError(gainedInput, false);
                 toggleError(maxInput, false);
            }
            
            // Если одно поле заполнено, а другое нет (кроме случая прогноза)
            if ((gainedIsFilled && !maxIsFilled) || (!gainedIsFilled && maxIsFilled && gainedInput.id.startsWith('gained-'))) {
                // Если заполнено только "Максимум", это не ошибка, это режим прогноза.
                // Если заполнено только "Получено", это ошибка.
                if (!maxIsFilled) {
                    toggleError(gainedInput, true);
                    isError = true;
                }
            }

            // В режиме прогноза (заполнен только Максимум) ошибку не показываем, если Максимум > 0
            if (!gainedIsFilled && maxIsFilled && max > 0) {
                toggleError(gainedInput, false);
                toggleError(maxInput, false);
            }
        }

        /**
         * Добавляет новое поле ввода оценки в список.
         * @param {string} type - Тип оценки ('sor' или 'soch').
         */
        function addAssessment(type) {
            const list = document.getElementById(`${type}-list`);
            list.insertAdjacentHTML('beforeend', createAssessmentInput(type));
            updateLabels(type);
            calculateGrade();
        }

        /**
         * Удаляет поле ввода оценки.
         * @param {string} id - ID оценки (например, 'sor-1').
         */
        function removeAssessment(id) {
            const container = document.getElementById(`container-${id}`);
            if (container) {
                container.remove();
            }
            const type = id.split('-')[0];
            updateLabels(type);
            calculateGrade();
        }
        
        /**
         * Обновляет нумерацию меток после добавления/удаления.
         * @param {string} type - Тип оценки ('sor' или 'soch').
         */
        function updateLabels(type) {
            const inputs = document.querySelectorAll(`#${type}-list > div`);
            inputs.forEach((container, index) => {
                const newId = `${type}-${index + 1}`;
                const oldId = container.id.replace('container-', '');
                
                // Переназначаем ID полей, если они существуют
                const gainedInput = document.getElementById(`gained-${oldId}`);
                const maxInput = document.getElementById(`max-${oldId}`);
                const predictionBlock = document.getElementById(`prediction-for-${oldId}`);
                
                if (gainedInput) {
                    gainedInput.id = `gained-${newId}`;
                    gainedInput.setAttribute('oninput', `validateInput('${newId}'); calculateGrade()`);
                }
                if (maxInput) {
                    maxInput.id = `max-${newId}`;
                    maxInput.setAttribute('oninput', `validateInput('${newId}'); calculateGrade()`);
                }
                if (predictionBlock) {
                    predictionBlock.id = `prediction-for-${newId}`;
                }

                container.id = `container-${newId}`;
                
                // Обновление текста метки
                const label = container.querySelector('label');
                const labelText = type === 'sor' ? 'СОР' : 'СОЧ';
                label.textContent = `${labelText} ${index + 1}`;
                
                // Обновление функции удаления
                container.querySelector('button').setAttribute('onclick', `removeAssessment('${newId}')`);
            });
            assessmentId = document.querySelectorAll('.input-item').length;
        }


        /**
         * Главная функция расчета четвертной оценки по формуле 50% СОР + 50% СОЧ.
         */
        function calculateGrade() {
            const sorInputs = document.querySelectorAll('#sor-list > div');
            const sochInputs = document.querySelectorAll('#soch-list > div');
            
            let totalSorGained = 0;
            let totalSorMax = 0;
            let totalSochGained = 0;
            let totalSochMax = 0;
            let isValid = true;
            
            // Баллы/Максимум для незаполненного (прогнозного) СОР/СОЧ
            let missingSorId = null; 
            let missingSochId = null;

            const resultMessage = document.getElementById('result-message');
            const finalPercentageDisplay = document.getElementById('final-percentage');
            const finalGradeDisplay = document.getElementById('final-grade');
            
            const resetResult = (message, color = 'text-gray-800') => {
                resultMessage.innerHTML = `<p class="${color} font-bold">${message}</p>`;
                finalPercentageDisplay.textContent = '—';
                finalGradeDisplay.textContent = '—';
                finalGradeDisplay.className = 'text-6xl font-extrabold text-gray-800 mt-2';
                // Скрываем все блоки прогноза при ошибке
                document.querySelectorAll('.prediction-block').forEach(block => block.classList.add('hidden'));
            }

            // 1. Сбор баллов, валидация и поиск "прогнозного" элемента
            const collectAndValidate = (inputs, type) => {
                let gainedSum = 0;
                let maxSum = 0;
                let missingId = null;
                
                inputs.forEach(container => {
                    const id = container.id.replace('container-', '');
                    const gainedInput = document.getElementById(`gained-${id}`);
                    const maxInput = document.getElementById(`max-${id}`);
                    const predictionBlock = document.getElementById(`prediction-for-${id}`);
                    
                    const gained = parseFloat(gainedInput.value);
                    const max = parseFloat(maxInput.value);
                    
                    const gainedIsFilled = gainedInput.value.trim() !== '';
                    const maxIsFilled = maxInput.value.trim() !== '';

                    // Проверяем наличие ошибки валидации, которая подсвечивает поля красным
                    const isInputError = gainedInput.classList.contains('border-red-500') || maxInput.classList.contains('border-red-500');
                    
                    if (isInputError) {
                        isValid = false;
                    } else if (gainedIsFilled && maxIsFilled) {
                        // Валидно и заполнено
                        gainedSum += gained;
                        maxSum += max;
                        predictionBlock.classList.add('hidden'); // Скрываем прогноз, если поле заполнено
                    } else if (!gainedIsFilled && maxIsFilled && max > 0) {
                        // Режим прогноза: Получено пусто, Максимум заполнен и корректен
                        missingId = id;
                        maxSum += max; // Добавляем максимальный балл в общую сумму для расчета текущего %
                        predictionBlock.classList.remove('hidden'); // Показываем блок прогноза
                    } else {
                        // Игнорируем пустые поля
                        predictionBlock.classList.add('hidden');
                    }
                });
                return { gainedSum, maxSum, missingId };
            };
            
            // Собираем данные СОР
            const sorData = collectAndValidate(sorInputs, 'sor');
            totalSorGained = sorData.gainedSum;
            totalSorMax = sorData.maxSum;
            missingSorId = sorData.missingId;
            
            // Собираем данные СОЧ
            const sochData = collectAndValidate(sochInputs, 'soch');
            totalSochGained = sochData.gainedSum;
            totalSochMax = sochData.maxSum;
            missingSochId = sochData.missingId;

            // Если есть ошибки валидации, останавливаем расчет
            if (!isValid) {
                resetResult('Пожалуйста, исправьте ошибки ввода (выделены красным).', 'text-red-600');
                return;
            }

            // Проверка наличия данных для расчета
            if (totalSorMax === 0 && totalSochMax === 0) {
                resetResult('Введите баллы для СОР и СОЧ.', 'text-gray-600');
                return;
            }
            if (totalSorMax === 0) {
                 resetResult('Для расчета необходимы баллы СОР (50% веса).', 'text-yellow-600');
                return;
            }
            if (totalSochMax === 0) {
                 resetResult('Для расчета необходимы баллы СОЧ (50% веса).', 'text-yellow-600');
                return;
            }

            // 2. Расчет Процентов
            // Процент СОР: (Сумма полученных СОР) / (Сумма максимальных СОР) * 100
            const sorPercentage = (totalSorGained / totalSorMax) * 100;
            // Процент СОЧ: (Сумма полученных СОЧ) / (Сумма максимальных СОЧ) * 100
            const sochPercentage = (totalSochGained / totalSochMax) * 100;

            // 3. Применение Формулы: (50% СОР) + (50% СОЧ)
            const finalGradePercentage = (sorPercentage * 0.5) + (sochPercentage * 0.5); 

            // 4. Определение Итоговой Оценки по шкале
            let finalMark = '2';
            let markColor = 'text-red-500';

            if (finalGradePercentage >= 85) {
                finalMark = '5';
                markColor = 'text-green-600';
            } else if (finalGradePercentage >= 65) {
                finalMark = '4';
                markColor = 'text-blue-500';
            } else if (finalGradePercentage >= 40) {
                finalMark = '3';
                markColor = 'text-yellow-600';
            }

            // 5. Отображение Результатов
            finalPercentageDisplay.textContent = finalGradePercentage.toFixed(2) + '%';
            finalGradeDisplay.textContent = finalMark;
            finalGradeDisplay.className = `text-6xl font-extrabold ${markColor} mt-2`;

            resultMessage.innerHTML = `
                <p class="text-sm text-gray-600 mt-4">
                    Общий процент СОР (${totalSorGained}/${totalSorMax}): **${sorPercentage.toFixed(2)}%**<br>
                    Общий процент СОЧ (${totalSochGained}/${totalSochMax}): **${sochPercentage.toFixed(2)}%**<br>
                    Итоговый процент: (${sorPercentage.toFixed(2)}% $\\times 0.5$) + (${sochPercentage.toFixed(2)}% $\\times 0.5$) 
                    = **${finalGradePercentage.toFixed(2)}%**.
                </p>
            `;
            
            // 6. Расчет прогноза (если есть незаполненный элемент)
            
            // Функция расчета минимального балла для оценки
            const calculatePrediction = (targetMark, totalGained, totalMax, missingItemMax, type) => {
                const targetPercentage = GRADE_THRESHOLDS[targetMark];
                if (targetPercentage === undefined) return null;

                const currentWeight = type === 'sor' ? 0.5 : 0.5;
                const otherWeight = 1 - currentWeight;
                
                // Процент, который должен дать СОР/СОЧ с пропущенным элементом:
                // Target % = (Своя % * 0.5) + (Чужая % * 0.5)
                // Target % * 2 = Своя % + Чужая %
                // Своя % = (Target % * 2) - Чужая %
                
                let requiredTotalPercentage = 0;
                let otherPercentage = 0;
                
                if (type === 'sor') {
                    // Целевой процент для СОР
                    otherPercentage = sochPercentage;
                    requiredTotalPercentage = (targetPercentage * 2) - otherPercentage;
                } else { // type === 'soch'
                    // Целевой процент для СОЧ
                    otherPercentage = sorPercentage;
                    requiredTotalPercentage = (targetPercentage * 2) - otherPercentage;
                }

                if (requiredTotalPercentage > 100) return `> ${missingItemMax}`; // Невозможно, нужно больше 100%
                if (requiredTotalPercentage < 0) return 0; // Уже гарантировано, нужно 0%

                // Необходимая сумма баллов: (requiredTotalPercentage / 100) * totalMax
                const requiredGainedTotal = (requiredTotalPercentage / 100) * totalMax;
                
                // Необходимый балл для недостающего элемента: requiredGainedTotal - totalGained (сумма уже набранных)
                const requiredGained = requiredGainedTotal - totalGained;
                
                const finalRequiredGained = Math.max(0, requiredGained);
                
                if (finalRequiredGained > missingItemMax) {
                     return `> ${missingItemMax}`; // Невозможно достичь этой оценки
                }
                
                return Math.ceil(finalRequiredGained);
            };

            // Обнуляем все блоки прогноза перед расчетом
             document.querySelectorAll('.prediction-block').forEach(block => block.classList.add('hidden'));


            if (missingSorId) {
                const missingItemMax = parseFloat(document.getElementById(`max-${missingSorId}`).value);
                
                const needed5 = calculatePrediction('5', totalSorGained, totalSorMax, missingItemMax, 'sor');
                const needed4 = calculatePrediction('4', totalSorGained, totalSorMax, missingItemMax, 'sor');
                const needed3 = calculatePrediction('3', totalSorGained, totalSorMax, missingItemMax, 'sor');
                
                const predictionHtml = `
                    <p class="font-bold text-indigo-700">Прогноз ${document.getElementById(`container-${missingSorId}`).querySelector('label').textContent}:</p>
                    <p>На 5 нужно: ${needed5} / ${missingItemMax} (${needed5 > missingItemMax ? 'Нев.' : 'Воз.'})</p>
                    <p>На 4 нужно: ${needed4} / ${missingItemMax} (${needed4 > missingItemMax ? 'Нев.' : 'Воз.'})</p>
                    <p>На 3 нужно: ${needed3} / ${missingItemMax} (${needed3 > missingItemMax ? 'Нев.' : 'Воз.'})</p>
                `;
                document.getElementById(`prediction-for-${missingSorId}`).innerHTML = predictionHtml;
                document.getElementById(`prediction-for-${missingSorId}`).classList.remove('hidden');
            }

            if (missingSochId) {
                const missingItemMax = parseFloat(document.getElementById(`max-${missingSochId}`).value);
                
                const needed5 = calculatePrediction('5', totalSochGained, totalSochMax, missingItemMax, 'soch');
                const needed4 = calculatePrediction('4', totalSochGained, totalSochMax, missingItemMax, 'soch');
                const needed3 = calculatePrediction('3', totalSochGained, totalSochMax, missingItemMax, 'soch');
                
                const predictionHtml = `
                    <p class="font-bold text-teal-700">Прогноз ${document.getElementById(`container-${missingSochId}`).querySelector('label').textContent}:</p>
                    <p>На 5 нужно: ${needed5} / ${missingItemMax} (${needed5 > missingItemMax ? 'Нев.' : 'Воз.'})</p>
                    <p>На 4 нужно: ${needed4} / ${missingItemMax} (${needed4 > missingItemMax ? 'Нев.' : 'Воз.'})</p>
                    <p>На 3 нужно: ${needed3} / ${missingItemMax} (${needed3 > missingItemMax ? 'Нев.' : 'Воз.'})</p>
                `;
                document.getElementById(`prediction-for-${missingSochId}`).innerHTML = predictionHtml;
                document.getElementById(`prediction-for-${missingSochId}`).classList.remove('hidden');
            }
        }

        // Инициализация полей СОР и СОЧ при загрузке страницы
        window.onload = function() {
            // Добавляем начальные поля (1 СОР, 1 СОЧ)
            addAssessment('sor');
            addAssessment('soch');
            // Приводим в порядок нумерацию и запускаем первый расчет
            updateLabels('sor');
            updateLabels('soch');
            calculateGrade();
        };

    </script>
</body>
</html>
